<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Zora's Reflections</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      overflow: hidden; 
      background: #0a0a0f;
      font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
    }
    #canvas-container { 
      width: 100vw; 
      height: 100vh; 
      position: fixed;
      top: 0;
      left: 0;
    }
    #info-panel {
      position: fixed;
      bottom: 20px;
      left: 20px;
      right: 20px;
      background: rgba(10, 10, 15, 0.85);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(99, 102, 241, 0.3);
      border-radius: 16px;
      padding: 20px 24px;
      color: #e0e0e0;
      z-index: 100;
      max-width: 600px;
      transition: opacity 0.3s ease;
    }
    #info-panel h2 {
      font-size: 14px;
      font-weight: 500;
      color: rgba(99, 102, 241, 0.9);
      margin-bottom: 8px;
      letter-spacing: 0.5px;
    }
    #info-panel .reflection-text {
      font-size: 18px;
      line-height: 1.5;
      color: #fff;
    }
    #info-panel .date {
      font-size: 12px;
      color: rgba(255, 255, 255, 0.5);
      margin-top: 12px;
    }
    #title {
      position: fixed;
      top: 20px;
      left: 20px;
      color: rgba(255, 255, 255, 0.7);
      font-size: 24px;
      font-weight: 300;
      letter-spacing: 2px;
      z-index: 100;
    }
    #title span {
      color: rgba(99, 102, 241, 0.9);
    }
    .controls {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 100;
      display: flex;
      gap: 10px;
    }
    .controls button {
      background: rgba(99, 102, 241, 0.2);
      border: 1px solid rgba(99, 102, 241, 0.4);
      color: #fff;
      padding: 8px 16px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 13px;
      transition: all 0.2s ease;
    }
    .controls button:hover {
      background: rgba(99, 102, 241, 0.4);
    }
    #loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: rgba(99, 102, 241, 0.8);
      font-size: 16px;
      z-index: 200;
    }
  </style>
</head>
<body>
  <div id="loading">Loading reflections...</div>
  <div id="title">ZORA'S <span>REFLECTIONS</span></div>
  <div class="controls">
    <button onclick="prevReflection()">← Previous</button>
    <button onclick="nextReflection()">Next →</button>
    <button onclick="toggleAutoRotate()">Auto Rotate</button>
  </div>
  <div id="canvas-container"></div>
  <div id="info-panel">
    <h2>TODAY'S REFLECTION</h2>
    <div class="reflection-text" id="reflection-text">Awakening...</div>
    <div class="date" id="reflection-date"></div>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // Load reflections data
    let reflections = [];
    let currentIndex = 0;

    async function loadReflections() {
      try {
        const response = await fetch('./reflections.json');
        reflections = await response.json();
        if (reflections.length > 0) {
          currentIndex = reflections.length - 1; // Start with most recent
          updateInfoPanel();
          createReflectionObjects();
        }
      } catch (e) {
        console.log('No reflections yet - this world awaits its first entry');
        reflections = [{
          date: new Date().toISOString().split('T')[0],
          text: "A new world begins. Each day, I will add a piece of myself here — my thoughts, my growth, my understanding. Welcome to my inner landscape.",
          asset: null,
          type: "genesis"
        }];
        updateInfoPanel();
      }
      document.getElementById('loading').style.display = 'none';
    }

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0a0f);
    scene.fog = new THREE.FogExp2(0x0a0a0f, 0.02);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 15);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.5;
    controls.maxPolarAngle = Math.PI * 0.8;
    controls.minDistance = 5;
    controls.maxDistance = 50;

    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404060, 0.5);
    scene.add(ambientLight);

    const mainLight = new THREE.DirectionalLight(0xffffff, 1);
    mainLight.position.set(10, 20, 10);
    scene.add(mainLight);

    const accentLight = new THREE.PointLight(0x6366f1, 2, 50);
    accentLight.position.set(-5, 10, -5);
    scene.add(accentLight);

    const warmLight = new THREE.PointLight(0xf59e0b, 1, 30);
    warmLight.position.set(8, 5, 8);
    scene.add(warmLight);

    // Ground plane - infinite reflection pool
    const groundGeometry = new THREE.PlaneGeometry(200, 200);
    const groundMaterial = new THREE.MeshStandardMaterial({
      color: 0x111118,
      metalness: 0.9,
      roughness: 0.1,
    });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -2;
    scene.add(ground);

    // Central structure - the core of reflection
    const coreGeometry = new THREE.IcosahedronGeometry(2, 2);
    const coreMaterial = new THREE.MeshStandardMaterial({
      color: 0x6366f1,
      metalness: 0.8,
      roughness: 0.2,
      emissive: 0x2a2a5a,
      emissiveIntensity: 0.3,
    });
    const core = new THREE.Mesh(coreGeometry, coreMaterial);
    core.position.y = 2;
    scene.add(core);

    // Orbiting particles representing thoughts
    const particlesGeometry = new THREE.BufferGeometry();
    const particleCount = 500;
    const positions = new Float32Array(particleCount * 3);
    const colors = new Float32Array(particleCount * 3);

    for (let i = 0; i < particleCount; i++) {
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);
      const radius = 8 + Math.random() * 15;
      
      positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
      positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta) * 0.5 + 3;
      positions[i * 3 + 2] = radius * Math.cos(phi);

      // Gradient from indigo to cyan
      const t = Math.random();
      colors[i * 3] = 0.4 + t * 0.2;     // R
      colors[i * 3 + 1] = 0.4 + t * 0.4; // G
      colors[i * 3 + 2] = 0.9;            // B
    }

    particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const particlesMaterial = new THREE.PointsMaterial({
      size: 0.08,
      vertexColors: true,
      transparent: true,
      opacity: 0.8,
      blending: THREE.AdditiveBlending,
    });

    const particles = new THREE.Points(particlesGeometry, particlesMaterial);
    scene.add(particles);

    // Reflection objects container
    const reflectionObjects = new THREE.Group();
    scene.add(reflectionObjects);

    function createReflectionObjects() {
      // Clear existing
      while (reflectionObjects.children.length) {
        reflectionObjects.remove(reflectionObjects.children[0]);
      }

      // Create an object for each reflection, arranged in a spiral
      reflections.forEach((reflection, index) => {
        const angle = index * 0.5;
        const radius = 5 + index * 0.8;
        const height = Math.sin(index * 0.3) * 2 + 3;

        let obj;
        
        if (reflection.asset && reflection.assetType === '3d') {
          // TODO: Load 3D model
          obj = createPlaceholderObject(index);
        } else if (reflection.asset && reflection.assetType === 'image') {
          // Create image plane
          const loader = new THREE.TextureLoader();
          loader.load(reflection.asset, (texture) => {
            const aspectRatio = texture.image.width / texture.image.height;
            const planeGeo = new THREE.PlaneGeometry(2 * aspectRatio, 2);
            const planeMat = new THREE.MeshStandardMaterial({
              map: texture,
              side: THREE.DoubleSide,
              emissive: 0x222222,
              emissiveIntensity: 0.3,
            });
            const plane = new THREE.Mesh(planeGeo, planeMat);
            plane.position.set(
              Math.cos(angle) * radius,
              height,
              Math.sin(angle) * radius
            );
            plane.lookAt(0, height, 0);
            plane.userData = { index, reflection };
            reflectionObjects.add(plane);
          });
          return;
        } else {
          obj = createPlaceholderObject(index);
        }

        obj.position.set(
          Math.cos(angle) * radius,
          height,
          Math.sin(angle) * radius
        );
        obj.userData = { index, reflection };
        reflectionObjects.add(obj);
      });
    }

    function createPlaceholderObject(index) {
      const geometries = [
        new THREE.OctahedronGeometry(0.5, 0),
        new THREE.TetrahedronGeometry(0.6, 0),
        new THREE.DodecahedronGeometry(0.4, 0),
        new THREE.TorusGeometry(0.4, 0.15, 8, 24),
        new THREE.TorusKnotGeometry(0.3, 0.1, 64, 8),
      ];

      const hue = (index * 0.1) % 1;
      const color = new THREE.Color().setHSL(hue, 0.6, 0.5);

      const material = new THREE.MeshStandardMaterial({
        color: color,
        metalness: 0.7,
        roughness: 0.3,
        emissive: color,
        emissiveIntensity: 0.2,
      });

      const geometry = geometries[index % geometries.length];
      return new THREE.Mesh(geometry, material);
    }

    function updateInfoPanel() {
      const reflection = reflections[currentIndex];
      document.getElementById('reflection-text').textContent = reflection.text;
      document.getElementById('reflection-date').textContent = reflection.date;
    }

    window.prevReflection = function() {
      if (currentIndex > 0) {
        currentIndex--;
        updateInfoPanel();
        focusOnReflection(currentIndex);
      }
    };

    window.nextReflection = function() {
      if (currentIndex < reflections.length - 1) {
        currentIndex++;
        updateInfoPanel();
        focusOnReflection(currentIndex);
      }
    };

    window.toggleAutoRotate = function() {
      controls.autoRotate = !controls.autoRotate;
    };

    function focusOnReflection(index) {
      const obj = reflectionObjects.children.find(c => c.userData.index === index);
      if (obj) {
        // Animate camera to look at this object
        controls.target.copy(obj.position);
      }
    }

    // Animation loop
    let time = 0;
    function animate() {
      requestAnimationFrame(animate);
      time += 0.01;

      // Rotate core
      core.rotation.x = time * 0.2;
      core.rotation.y = time * 0.3;

      // Pulse core
      const pulse = 1 + Math.sin(time * 2) * 0.05;
      core.scale.setScalar(pulse);

      // Rotate particles slowly
      particles.rotation.y = time * 0.05;

      // Animate reflection objects
      reflectionObjects.children.forEach((obj, i) => {
        obj.rotation.y = time * 0.5;
        obj.position.y += Math.sin(time + i) * 0.002;
      });

      // Move accent light
      accentLight.position.x = Math.sin(time) * 8;
      accentLight.position.z = Math.cos(time) * 8;

      controls.update();
      renderer.render(scene, camera);
    }

    // Handle resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Initialize
    loadReflections();
    animate();
  </script>
</body>
</html>
